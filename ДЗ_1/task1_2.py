# Выполнить логические побитовые операции «И», «ИЛИ» и др. над числами 5 и 6. Выполнить над числом 5 побитовый сдвиг вправо
# и влево на два знака. Объяснить полученный результат.
x = 5
y = 6
# 'ИЛИ оператор копирует бит, если тот присутствует в, хотя бы,  одном операнде.
bit_or = x | y

# "Исключительное ИЛИ" оператор копирует бит только, если бит присутствует в одном из операндов, но не в обоих сразу.
bit_xor = x ^ y

# "И" оператор копирует бит в результат только, если бит присутствует в обоих операндах.
bit_and = x & y

# Побитовое отрицание меняет биты на обратные, там, где была единица становится ноль и наоборот.
bit_not_n1 = ~x
bit_not_n2 = ~y

# Побитовый сдвиг вправо. Значение левого операнда сдвигается вправо на количество бит, указанных в правом операнде.
bit_shift_right = x >> 2

# Побитовый сдвиг влево. Значение левого операнда сдвигается влево на количество бит, указанных в правом операнде.
bit_shift_left = x << 2

print(f'Побитовое «ИЛИ» (OR) для {bin(x)} и {bin(y)}: {bin(bit_or)} ({bit_or})')

print(f'Исключающее «ИЛИ» (XOR) для {bin(x)} и {bin(y)}: {bin(bit_xor)} ({bit_xor})')

print(f'Побитовое «И» (AND) для {bin(x)} и {bin(y)}: {bin(bit_and)} ({bit_and})')

print(f'Побитовое отрицание (NOT) для {bin(x)}: {bin(bit_not_n1)} ({bit_not_n1}) и для {bin(y)}: {bin(bit_not_n2)} ({bit_not_n2})')

print(f'Битовый сдвиг вправо для {bin(x)}: {bin(bit_shift_right)} ({bit_shift_right})')

print(f'Битовый сдвиг влево для {bin(x)}: {bin(bit_shift_left)} ({bit_shift_left})')